\chapter{Tendermint Consensus}

This chapter presentes the Tendermint consensus algorithm and communicates the intuitions underlying its security.

\section{Tendermint Overview}

Tendermint is an algorithm for a secure, replicated state machine that operates on batches, or blocks, of transactions at a time.
The algorithm is summarized in FIGURE and it's key properties are summarized in FIGURE. 

Tendermint consensus begins with a set of \emph{validators}, each of which is responsible for maintaining a full copy of the replicated state,
and for participating in consensus by proposing new blocks and voting on proposals.
Validators take turns proposing new blocks in \emph{rounds}, such that at any given round there is at most one valid proposer.
Validators engage in two phases of voting on a proposed block before it is committed, 
and follow a simple locking mechanism which prevents any coalition of up to one third malicious validators from comprimising safety.

Blocks are chained together by including in the metadata, or header, of a block the hash of the previous one,
such that there is only one valid block at each successive height in the chain.
It may take multiple rounds to commit a block at a given height due to the asynchrony of the network,
and the network may halt altogether if more than one-third of the validators are offline or partitioned off.

The consensus algorithm can be roughly divided into the following, somewhat orthogonal, components:

\begin{itemize}

\item{Proposals: a new block must be proposed by the correct proposer at each round, and gossipped to the other validators. If a proposal is not received in sufficient time, the proposer should be skipped}

\item{Voting: two phases of voting must occur to ensure optimal Byzantine Fault Tolerance. They are called "prevote" and "precommit". A set of precommits from more than two-thirds of the validators for the same block at the same round is considered a commit.}

\item{Locks: Tendermint ensures that no two validators commit a different block at the same height, presuming less than one-third of the validators are malicious. This is done using a locking mechanism which determines how a validator may pre-vote or pre-commit depending on previous pre-votes and pre-commits at the same height. Note that this locking mechanism must be carefully designed so as to not compromise liveness}

\end{itemize}

As will be seen, the design of Tendermint's safety mechanism provides greater gaurantees in the event of Byzantine failure than competing algorithms
in particular as it is able to identify and hold accountable the validators responsible for the failure.

\section{Tendermint Basics}

In order to provide tolerance to a single Byzantien fault, a Tendermint network must contain at minimum four validators.
Each validator must possess an assymetric cryptographic key-pair for producing digital signatures.
Validators start from a common \emph{genesis} state, known as the genesis block, which contains the initial list of validators in terms of their public keys.
All proposals and votes must be signed by the respective validator's private key, and can hence be verified by every other validator.
It is helpful to assume that up to one-third of validators are malicious, co-operating in arbitrary ways to subvert system safety or liveness.

Consensus begins for block 1, round 0; the proposer is the first validator listed in the genesis.
Validators can vote to move to the next round, and hence skip a proposer, using the same mechanism they do to vote on an actual proposed block - 
the result is that they proceed to the next round at the same height, rather than committing a block and proceeding to round 0 at the next height.
This way, they have multiple opportunties to come to consensus in the event of network asynchrony or crashed nodes.

Rounds proceed in a fully asynchronous manner - a validator makes progress only after hearing from more than two-thirds of the other validators.
This relieves any sort of dependence on synchronized clocks or bounded network delays.
However, local processor clocks are utilized to determine when to skip a proposer, using the \emph{TimeoutPropose} parameter.
That is, if a validator does not receive a proposal within TimeoutPropose of entering a new round, it can vote to skip the proposer.
Of course, the proposer is not actually skipped until more than two-thirds of validators agree to skip to the next round.

To round-skip safely, a small number of \emph{locking} rules are introduced which force validators to justify their votes.
While we don't necessarily require them to broadcast their justifications in real time, we do expect them to keep them,
such that they can be brought forth as evidence in the event of a total Byzantine failure.
This accountability mechanism enables Tendermint to provide stronger gaurantees in the face of such failure.

Validators communicate using a diverse set of messages for managing the blockchain, application state, peer network, and consensus.
The core consensus algorithm, however, consists of just the following two messages:

\begin{itemize}
\item{ProposalMsg: contains a proposal for a block at a given height and round, signed by the proposer}
\item{VoteMsg: contains a signed vote for a proposal}
\end{itemize}

In practice, we use additional messages to optimize the gossiping of block data and votes, as discussed LATER.

\section{Proposing}

Each round begins with a proposal. 
The propser for the given round takes a batch of recently received transactions, composes a block,
and broadcasts a signed ProposalMsg containing the block.
If the proposer is Byzantine, it might broadcast different proposals to different validators.

Proposers are ordered via a simple, deterministic round robin, 
so only a single propsoer is valid for a given round, 
and every validator knows the correct proposer. 
If a proposal is received for a lower round, or from an incorrect proposer, it is rejected.

Upon entering a new round, validators wait ProposalTimeout to receive a complete proposal before broadcasting their pre-vote.
The ProposalTimeout thus serves as a critical paramter for tuning the performance of the system,
as it determines how much latency is permitted from proposers before validators start voting to skip them.

\section{Voting}

Once a complete proposal is received by a validator, 
it signs a pre-vote for that proposal and broadcasts it to the network.
If a validator does not receive a proposal within ProposalTimeout, 
it signs and broadcasts a pre-vote for nil (nil-pre-vote) instead.

In Byzantine environments, a single stage of voting is not sufficient to achieve consensus.
For instance, consider a network with validators Val1, Val2, Val3, and Val4, where Val1 is Byzantine.
Suppose Val1 both pre-votes for the proposal, and nil-pre-votes.
Suppose Val2 and Val3 pre-vote the proposal, while Val4 nil-pre-votes.
Now, suppose Val2 sees all the pre-votes, and hence commits the proposed block,
but Val3 and Val4 don't see the pre-votes for the proposal from Val1 and Val2.
Now Val3 and Val4 go to the next round, while Val2 has already committed, and only Val1 is Byzantine.
Val1 joins them in the next round and they commit a block.
Now Val2 has committed one block while Val3 and Val4 have committed another while less than one-third of the validators (only Val1) are Byzantine.

We digressed through that example to illustrate why only using pre-votes (a single round of voting) 
is not sufficient if some validators can be Byzantine.
A single round of voting allows validators to tell eachother what they know about the proposal.	
But to tolerate Byzantine faults (which amounts, essential to lies, fraud, deceipt, etc.), 
they must also tell eachother what they know about what other validators have professed to know about the proposal.

Thus, pre-voting is a preparation phase, in which validators synthesize what other validators know.
A pre-vote for a block is a vote to prepare the network to commit the block.
A nil-pre-vote is a vote to prepare the network to move to the next round.
In an ideal round with an online proposer, more than two-thirds of validators will pre-vote for the proposal.
A set of more than two-thirds of pre-votes for a single block at a given round is known as a \epmh{polka} \footnote{The original term used was PoL, or PoLC, for Proof-of-Lock or Proof-of-Lock-Change, as discussed LATER. The term evolved to polka as it was realized the validators are doing the polka}.
A set of more than two-thirds of pre-votes for nil is a \emph{nil-polka}

When a validator recieves a polka (read: more than two-thirds pre-votes for a single block), 
it signals that the network is prepared to commit the block,
and serves as justification for the validator to sign and broadcast a pre-commit vote for that block.
Sometimes, due to network asynchrony, a validator may not receive a polka, or there may not have been one. 
In that case, the validator is not justified in signing a pre-commit for that block, 
and must therefore sign and publish a pre-commit vote for nil (nil-pre-commit).
That is, a pre-commit without justification from a polka is considered malicious behaviour.

A pre-commit is a vote to actually commit the block.
A nil-pre-commit is a vote to actually move to the next round.
If a validator receives more than two-thirds pre-commits for a single block, 
it considers that block committed, computes the resulting state,
and moves on to round 0 at the next height.
If a validator receives more than two-thirds nil-pre-commits,
it moves on to the next round.

\section{Safety}

Ensuring safety across rounds can be tricky, 
as circumstances must be avoided which would provide justification for two different blocks being committed at two different rounds at the same height.
In Tendermint, this problem is solved via a \emph{locking} mechanism.
In essence, once a pre-commit is cast, a validator is \emph{locked} on the block associated with the pre-commit.
There are two rules of locking:

\begin{itemize}
\item{Prevote-the-Lock: a validator must pre-vote for the block they are locked on.}
\item{Release-Lock-on-Polka: a validator may only release a lock after seeing a polka or nil-polka at a round greater than that at which it locked}
\end{itemize}

Prevote-the-Lock prevents validators from pre-committing one block in one round, 
and then contributing to a polka for a different block in the next round, 
which could compromise safety.

Release-Lock-on-Polka allows validators to unlock if they pre-committed something the rest of the network doesn't want to commit,
thereby protecting liveness, but does it in a way that does not compromise safety.
This is because unlocking is only permitted if there has been a polka, which doesn't include the locked validator,
in a round after that in which the pre-commit was made that locked the validator.

\section{Crash Faults}

\section{Byzantine Faults}

\section{Availability}

\section{Conclusion}

