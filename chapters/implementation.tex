\chapter{Implementation}
\label{ch:implementation}

The reference implementation of Tendermint is written in Golang \cite{golang} and hosted at https://github.com/tendermint/tendermint.
Golang is a C-like language with a rich standard library, concurrency primitives for light-weight massively concurrent executions,
and a development environment optimized for simplicity and efficiency.

\section{Libraries}

The code uses a number of packages which are modular enough to be isolated as their own libraries.
These packages were written in the most part by Jae Kwon, with bug fixes, tests, and the occasional feature contributed by the author.
The most important of these packages are described in the following sub-sections.

\subsection{Binary Serialization}

Tendermint uses a binary serialization algorithm optimized for simplicity and determinism.
It supports all integer types (including varints, which are encoded with a one-byte length prefix),
strings, byte arrays, and time (unix time with millisecond precision).
It also supports arrays of any type and structs (encoded as a list of ordered values, ignoring keys).
It is somewhat inspired by Go's type system, especially its use of interface types, 
which can be implemented as one of many concrete types.
Interfaces can be registered and each concrete implementation given a leading type-byte in its encoding.

See github.com/tendermint/go-wire for more details.

\subsection{Cryptography}

Consensus algorithms such as tendermint use three primary cryptographic primitives: digital signatures, hash functions, and authenticated encryption.
While many implementations exist of numerous different signatures and hash functions, 
choosing a cryptography library for enterprise software is no trivial task, given especially the profound insecurity of the world's most used security library 
(ie. OpenSSL \ref{openssl_insecurity}).

Contributing to the insecurity of cryptographic systems is the potential deliberate undermining of their security properties by government agencies 
such as the NSA, who, in collaboration with the NIST, have designed and standardized many of the most popular cryptographic algorithms in use today. 
Given the apparent unlawfulness of such agencies, as popularized by Edward Snowden \ref{snowden}, 
many in the cryptography community, including at Tendermint, prefer to use algorithms designed in an open, academic environment.

Tendermint uses RIPEMD160 as its hashing algorithm, which produces 20-byte outputs. 
It is used in the merkle trees of transactions and validator signatures, and for computing the block hash.
Go provides an implemention in its extended library. RIPEMD160 is also used as one of two hashing functions by Bitcoin in the derrivation of addresses from public keys.

As it's digital signature scheme, Tendermint uses Schnorr signatures over the ED25519 elliptic curve. 
ED25519 was designed in the open by Dan Bernstein \ref{ed25519}, with the intention of being high performance and easy to implement without introducing vulnerabities.

In response to the failure of the cryptography community to provide cryptography libraries that are sufficiently easy to use without introducing vulnerabilites,
Bernstein also introduced NaCl, a high level library for doing authenticated encryption. Tendermint uses the implemention provided by Go in its extended library.

\subsection{Merkle Hash Tree}

Merkle trees function much like other tree based data-structures, 
with the additional feature that it is possible to produce a proof of membership of a key in the tree that is logarithmic in the size of the tree.
This is done by recursively concatenating and hashing keys in pairs until only a single hash is left, the root hash of the tree.
For any leaf in the tree, a trail of hashes leading from it to the root serves as proof of its membership \ref{fig:merkletree}.
This makes merkle trees particularly useful for p2p file-sharing applications, where pieces of a large file can be verified as belonging to the file without
having all the pieces. Tendermint uses this mechanism to gossip block parts on the network, where the root hash is included in the block proposal.

Tendermint also provides an self-balancing, merklized binary tree, modelled after the AVL tree \ref{avl}, as a tmsp service called merkleeyes.
Merklization is used to trivially implement copy-on-write, yielding an immutable AVL tree, or IAVL tree.
The IAVL tree can be used for storing state of dynamic size, allowing lookups, inserts, and removals in logarithmic time.

\subsection{P2P Networking}

The P2P networking used by Tendermint is described more fully in Chapter \cite{ch:networking}.

\subsection{RPC}

\section{Reactors}

NOTE: this should be moved to Chapter \cite{ch:networking}

The Tendermint node is composed of multiple concurrent reactors, 
each managing a state machine sending and receiving messages to peers over the network.
Reactors synchronize by locking shared datastructures, but the points of synchronization are kept to a minimum,
so each reactor runs mostly concurrently with the others.

\subsection{Mempool}

The mempool reactor manages the mempool, 
which caches transactions before they are packed in blocks and committed.
The mempool state machine uses a subset of the application's state machine to check the validity of transactions ...

\subsection{Consensus}

The consensus reactor manages the consensus state machine, which handles proposals, voting, locking, 
and the actually committing of blocks.
The state machine is managed using a few persistent go-routines, 
which order received messages and enable them to be played back deterministically to debug the state.
These go-routines include the readLoop, for reading off the queue of receivied messages, 
and the timeoutLoop, for registering and triggering timeout events. 

Transitions in the consensus state machine are made either when a complete proposal and block are received,
or when more than two-thirds of either pre-votes or pre-commits have been received at a given round.
Transitions result in the broadcast of proposals, block data, or votes, which are queued on the internalReqQueue,
and processed by the readLoop in serial with messages received from peers.
This puts internal messages and peer messages on equal footing as far as being inputs to the consensus state machine, 
but allows internal messages to be processed faster, as they don't sit in the same queue as those from peers.

\subsection{Blockchain}

The blockchain reactor syncs the blockchain using a much faster technique than the consensus reactor.
Namely, validators request blocks of incrementing height until none of their peers have blocks of any higher height.
Blocks are collected in a blockpool and synced to the blockchain by a worder routine that periodically takes blocks from the pool
and validates them against the current chain.

Once the blockchain reactor finishes syncing up, it turns on the consensus reactor to take over.

\section{Other Considerations}
