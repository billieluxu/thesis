\chapter{Building Applications}

Tendermint is designed to be a general purpose algorithm for replicating a deterministic state machine.
It uses the Tendermint Socket Protocol (TMSP) to standardize communication between the consensus engine and the state machine,
enabling application developers to build their state machines in any programming language, 
and have it automatically replicated via Tendermint's BFT algorithm.

\section{Background}

Applications on the internet can in general be characterized as containing two fundamental components:

\begin{itemize}
\item{Engine: handles core security, networking, replication functionality. Typically a webserver, like Apache or NginX, when powering a web app, or a consensus algorithm when powering a distributed application}
\item{State-machine: the actual application code that processes transactions received from the engine  and updates internal state}
\end{itemize}

This separation of concerns enables application developers to write state-machines in any programming language representing arbitrary applications,
on top of an engine which may be specialized for its performance, security, useability, support, etc.

Unlike web-servers and their applications, processes communicating over a socket via the Common Gateway Interface (CGI) protocol,
consensus algorithms have traditionally had much less useable or less general purpose interfaces to build applications on top of.
Some, like zookeeper, etcd, consul, and other distributed key-value stores, 
provide HTTP interfaces to a particular instance of simple key-value application, 
with some more interesting features like compare-and-swap operations and watch notificaitons.
But they do not give the application developer control of the state-machine code itself.

Demand for such a high-level of control over the state-machine running above a consensus engine has been driven primarily by the success of Bitcoin and the consequent interest in blockchain technology.
By building more advanced applications directly into the consensus, 
users, developers, regulators, etc. can achieve greater security gaurantees on arbitrary state-machines, 
far beyond key-value stores, like currencies, exchanges, supply-chain management, governance, and so on.

Tendermint aims to provide the fundamental interface and consensus engine upon which such applications might be built.

\section{Tendermint Socket Protocol}

The TMSP defines the core interface by which the consensus engine communicates with the application state machine.
The interface definition consists of a number of message types, specified using Google's Protobuf \ref{protobuf}, 
that are length-prefixed and transmitted over a socket.

TMSP is implemented as a fully asynchronous server, 
where message types come in pairs of request and response,
and where a special message type, Flush, pushes any buffered messages over the connection and awaits all responses.

At the core of the TMSP are two messages: AppendTx and Commit.
Once a block is committed by the consensus, 
the engine calls AppendTx on each transaction in the block, 
passing it to the application state-machine to be processed.
If the transaction is valid, it will result in a state-transition in the application.

Once all AppendTx calls have returned, the consensus engine calls Commit,
causing the application to commit to the latest state, and persist it to disk.

\section{Separating Agreement and Execution}

Using the TMSP affords us an explicit separation between consensus, or agreement on the order of transactions, 
and their actual execution in the state-machine.
In particular, we achieve consensus on the order first, and then execute the ordered transactions.
This separation actual improves the systems fault tolerance \ref{yin2003separating}:
while 3f+1 replicas are still needed for agreement to tolerate f Byzantine failures, 
only 2f+1 replicas are needed for execution to tolerate f Byzantine failures.

On the other hand, the fact that transactions are executed after they are ordered results in possibly invalid transactions,
which can waste system resources. 
This is solved using an additional TMSP message, CheckTx, which is called by the transaction pool,
allowing it to check whether the transaction would be valid against the latest state.
Note, however, that the fact that commits come in blocks at a time introduces complexity in the handling of CheckTx messages.
In particular, applications are expected to maintain a second state-machine that executes only those rules of the main state-machine pertaining to a transactions validity. 
This second state-machine is updated by CheckTx messages and is reset to the latest committed state after every commit.
In essence, they describe the transaction pool's filter rules.

\section{Microservice Architecture}

Adopting separation of concerns as a strategy in application design is generally considered wise practice.
In particular, many large scale application deployments today adopt a microservice architecture,
wherein each functional component is implemented as a standalone network service, 
and typically encapsulated in a linux container (eg. using Docker) for efficient deployment, scalability, and upgradeability.

Applications running above Tendermint consensus will often be decomposable into microservices.
For instance, many applications will utilize a key-value store for storing state.
Running the key-value store as an independent service is quite common, 
in order to take advantage of the data stores specialized features, such as high-performance data types or merklization.

Another important microservice for applications is a governance module, 
which manages a certain subset of TMSP messages, enabling the application to control validator set changes.
Such a module can become a powerful paradigm for governance in BFT systems.

Some applications may utilize a native currency or account structure for users.
It may thus be useful to provide a module which supports basic elements of eg. handling digital signatures and managing account dynamics.

The list of possible microservices to compose a complex TMSP application goes on. 

\section{Determinism}

The most critical caveat about building applications using TMSP is that they must be deterministic.
That is, for the replicated state-machine to not compromise safety, 
every node must obtain the same result when executing the same transaction against the same state.

There are many sources of non-determinism in programming languages, most obviously via random numbers and time,
but also, for instance, via the use of floats, and by iteration over hash tables.
The strict restriction on determinism, and its notable lacking from every major programming language,
prompted Ethereum to develop its own, Turing-complete, fully deterministic virtual machine,
which forms the platform for application developers to build applications above the Ethereum blockchain.
While deterministic, it has many quirks, such as 32-byte stack words, storage keys, and storage values,
and no support for byte-shifting operations - everything is big number arithmetic.

Deterministic programming is not unprecedented, and is in fact well studied in the world of real-time, lockstep, multi-party gaming.
Such games constitute another example of replicated state machines, and are quite similar in many ways to consensus algorithms.
Application developers building with TMSP are encouraged to study their methods, and to take care when implementing their application.
On the one hand, the use of functional programming languages and proof methods can enable the construction of correct programs.
On the other, compilers are being built to translate possibly non-deterministic programs to canonically deterministic ones \ref{deterministicjs}

\section{Termination}

If determinism is critical for preserving safety, termination of transaction execution is critical for preserving liveness.
It is, however, not in general possible to determine whether a given program halts for even a single input, let alone all of them,
a problem known as the Halting Problem \ref{halting}.

Ethereum's virtual machine solves the problem by chargin for each operation in the execution.
This way, a transaction is gauranteed to terminate when the sender runs out of funds.
Such metering may be possible in a more general case, 
via compilers that compile programs to metered versions of themselves.

It is difficult to solve this problem without significant overhead.
In essence, a validator cannot tell if an execution is in an infinite loop or is just slow, but nearly complete.
It may be possible to use the Tendermint consensus protocol to decide on transaction timeouts, 
such that more than two-thirds of validators must agree that a transaction timed out and is thus considered invalid (ie. having no effect on the state)
However, we do not pursue the idea further here, leaving it to future work. 
In the meantime, it is expected that applications will undergo thorogh testing before being deployed in any consensus system.

\section{Examples}

TODO: dummy, counter, basecoin, merkleeyes, eris-db, geth, etcd

\section{Conclusion}

TMSP provides a simple yet flexible means to build arbitrary applications,
in any programming language,
that inherit BFT state-machine replication from the Tendermint consensus algorithm.
It plays much the same role for a consensus engine and an application that, for instance, CGI plays for Apache and Wordpress.
However, application developers must take special care to ensure their applications are deterministic, and that transaction executions terminate.

